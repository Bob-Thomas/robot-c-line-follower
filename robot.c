/**
   DAVE THE LINE FOLLOWING ROBOT.
   This is the brain of dave please be careful with it.
**/
#pragma config(Sensor, S1, rightTracker, sensorColorNxtFULL)
#pragma config(Sensor, S2, leftTracker, sensorLightActive)
#pragma config(Sensor, S3, vision, sensorSONAR)
#pragma config(Sensor, S4, button, sensorTouch)
#pragma config(Motor, motorB, mLeft, tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor, motorC, mRight, tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
    Define some constant variables
**/
#define SPEED 20
#define ROTATION_SPEED  25
#define BLACK_OFFSET 10
#define WHITE_OFFSET 15

//Initialize global variables for the sensors
int white, black = 0;

//Initialize global variables for bluetooth connection
const int kMaxSizeOfMessage = 30;
const int INBOX = 5;
TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte  nRcvBuffer[kMaxSizeOfMessage];
string command = "";

/**
    Simple movement functions
**/
void forward(int new_speed) {
  motor[mLeft]  = new_speed;
  motor[mRight] = new_speed;
}

void left(int rotation_speed) {
  motor[mLeft]  = SPEED * 0.3;
  motor[mRight] = SPEED * 2.5;
}

void right(int rotation_speed) {
  motor[mLeft]  = SPEED * 2.5;
  motor[mRight] = SPEED * 0.3;
}

/**
    Function that overtime decreases Dave's speed until it stopped moving.
**/
void slow_stop(int speed) {
  for (int i = speed; i > 0; i--) {
    forward(i);
    wait1Msec(10);
  }
  motor[mLeft]  = 0;
  motor[mRight] = 0;
}

/**
    Let dave play a tone
**/
void play_sound(int range) {
  playImmediateTone((range / 2), 3);
}

/**
    Checks for bluetooth messages and reads them.
    Fills the given string with the message.
**/
void getBlootoot(string& s) {
  nSizeOfMessage = cCmdMessageGetSize(INBOX);

  if (nSizeOfMessage > kMaxSizeOfMessage) nSizeOfMessage = kMaxSizeOfMessage;

  if (nSizeOfMessage > 0) {
    nBTCmdRdErrorStatus =
      cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    nRcvBuffer[nSizeOfMessage] = '\0';
    stringFromChars(s, (char *)nRcvBuffer);
  }
}

// light sensor
// > 60 - white
// < 40 - black

// color sensor
// 6 - white
// 1 - black

/**
    Main function where dave gets active
**/
void startRobot() {
  //Initialize local variables
  int running    = 1;
  int blocked    = 0;
  int stopped    = 0;
  string command = "";

  /**
    The main loop where everything that dave does happens
  **/
  while (running) {
     /**
        Initialize the variables
        And some helpful values to display on the nxt display
     **/
    int light = SensorValue[leftTracker];
    int color = SensorValue[rightTracker];
    nxtDisplayTextLine(0, "left: %d",    SensorValue[leftTracker]);
    nxtDisplayTextLine(1, "right: %d",   SensorValue[rightTracker]);
    nxtDisplayTextLine(6, "stopped: %d", stopped);

    //Check for bluetooth command
    getBlootoot(command);

    //If there is a bluetooth command in memory show it on the nxt screen
    if (command != "") {
      nxtDisplayTextLine(3, command);
    }

    /**
        If the command given equals to DOWN stop the Dave and let it wait.
    **/
    if (command == "DOWN") {
      stopped = 1;
      slow_stop(SPEED);
      command = "";
    }

    /**
        If the command given equals to UP start Dave again
    **/
    if (command == "UP") {
      stopped = 0;
      forward(SPEED);
      command = "";
    }

    //If Dave is moving play a sound
    if (!stopped && !blocked) {
      play_sound(SensorValue[leftTracker] * 80);
    }

    //If Dave is moving
    if (!stopped) {

      /**
        If the color and light sensor both see black.
        Slow down dave and check if there is a command filled in the memory.
        Execute command going LEFT or RIGHT on a crossroad if no command is given
        Dave will go forward
      **/
      if ((light < (black + 10)) && (color == 1)) {
        slow_stop(SPEED);
        nSizeOfMessage = 0;
        nxtDisplayTextLine(3, command);

        int passed  = 0;
        int offroad = 0;

        if (command == "LEFT") {
          while (true) {
            int light = SensorValue[leftTracker];

            if ((light > (white)) && (offroad == 0)) {
              offroad = 1;
            }

            if ((light < (black)) && (offroad == 1)) {
              passed = 1;
            }

            if (((light < (black)) && (offroad == 0)) ||
                ((light > (white)) && (passed == 0))) {
              left(ROTATION_SPEED);
            }

            if ((light < (black)) && (offroad == 1) && (passed == 1)) {
              command = "";
              break;
            }
          }
        }

        if (command == "RIGHT") {
          while (true) {
            int color = SensorValue[rightTracker];

            if ((color == 6) && (offroad == 0)) {
              offroad = 1;
            }

            if ((color == 1) && (offroad == 1)) {
              passed = 1;
            }

            if (((color == 1) && (offroad == 0)) ||
                ((color == 6) && (passed == 0))) {
              right(ROTATION_SPEED);
            }

            if ((color == 1) && (offroad == 1) && (passed == 1)) {
              command = "";
              break;
            }
          }
        }
      }
      else if ((light > (white)) && (color == 6)) {
        //If both sensors are on white go forward
        forward(SPEED);
      }
      else if (color  == 1) {
        //If the color sensor is on black adjust dave by turning right.
        right(ROTATION_SPEED);
        wait1Msec(5);
      }
      else if (light < (black)) {
        //If the sensor sensor is on black adjust dave by turning left.
        left(ROTATION_SPEED);
        wait1Msec(5);
      }
    }

    if ((SensorValue(vision) < 25) || ((SensorValue(vision) == 255) && blocked)) {
      //If Dave sees a obstacle closer than 25cm it slows down and stops.
      blocked = 1;
      if (blocked) {
        slow_stop(0);
      }
      wait1Msec(500);
    } else {
      blocked = 0;
    }
  }
}

/**
    Simple function to display a pixel smiley on the nxt display
**/
void DisplaySmiley(int x, int y) {
  nxtDrawEllipse(x - 5, y + 5, x + 5, y - 5);
  nxtSetPixel(x - 2, y + 2);
  nxtSetPixel(x + 2, y + 2);
  nxtSetPixel(x,     y - 2);
  nxtSetPixel(x - 1, y - 2);
  nxtSetPixel(x + 1, y - 2);
  nxtSetPixel(x - 2, y - 1);
  nxtSetPixel(x + 2, y - 1);
},

/**
    Calibration function for the dave the ROBOT
    Gives the user the ability to calibrate dave for different environments.
    By using a 3 step program to calibrate first white then black and then start the robot
**/
void calibrate() {
  nxtDisplayTextLine(0, "Dave Calibration");

  while (!white) {
    nxtDisplayTextLine(1, "Please place dave");
    nxtDisplayTextLine(2, "on white and press");
    nxtDisplayTextLine(3, "the button.");
    nxtDisplayTextLine(5, "white: %d", SensorValue[leftTracker]);

    if (SensorValue[button]) {
      white = SensorValue[leftTracker];
      break;
    }
  }

  nxtDisplayTextLine(1, "WHITE COMPLETE");
  nxtDisplayTextLine(2, "");
  nxtDisplayTextLine(3, "");
  wait1Msec(1500);

  while (!black) {
    nxtDisplayTextLine(1, "Please place dave");
    nxtDisplayTextLine(2, "on black and press");
    nxtDisplayTextLine(3, "the button.");
    nxtDisplayTextLine(5, "black: %d", SensorValue[leftTracker]);

    if (SensorValue[button]) {
      black = SensorValue[leftTracker];
      break;
    }
  }

  eraseDisplay();
  nxtDisplayBigTextLine(0, "COMPLETE");
  nxtDisplayTextLine(2, "press button to");
  nxtDisplayTextLine(3, "start the dave.");
  DisplaySmiley(50, 25);
  wait1Msec(1000);

  while (true) {
    if (SensorValue[button]) {
      eraseDisplay();
      black = black + BLACK_OFFSET;
      white = white - WHITE_OFFSET;
      startRobot();
      break;
    }
  }
}

/**
    Main task that starts the calibration function
**/
task main()
{
  calibrate();
}
