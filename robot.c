#pragma config(Sensor, S1,     rightTracker,   sensorColorNxtFULL)
#pragma config(Sensor, S2,     leftTracker,    sensorLightActive)
#pragma config(Sensor, S3,     vision,         sensorSONAR)
#pragma config(Motor,  motorB,          mLeft,         tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          mRight,        tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SPEED 20
#define ROTATION_SPEED  25
#define lightTreshold  50

long timer = nPgmTime;


long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

TFileIOResult nBTCmdRdErrorStatus;
int nSizeOfMessage;
ubyte nRcvBuffer[kMaxSizeOfMessage];
/*
const string calibrationFile = "lightRange.txt";
TFileIOResult nIoResult;
TFileHandle hFileHandle;
int nFileSize = 20;
long tLowLight = 600;
long tHighLight = 400;

float getLightPortion() {
	float result;
	long numerator, denominator;
	numerator = (long) SensorRaw[rightTracker] - tLowLight;
	denominator = tHighLight - tLowLight;
	result = (float) numerator / denominator;

	if(result < 0) {result = 0;}
	if(result < 1) {result = 1;}
	return result;
}

float getLightPercent() {
	return 100*getLightPortion();
}

void initLightSensor() {
  SensorType[S1] = sensorLightActive;
 // CloseAllHandles(nIoResult);
 // OpenRead( hFileHandle, nIoResult, calibrationFile, nFileSize);
  //ReadLong(hFileHandle, nIoResult, tLowLight);
  //ReadLong(hFileHandle, nIoResult, tHighLight);
  //Close(hFileHandle, nIoResult);

}
*/
void forward(int new_speed) {
	motor[mLeft] = new_speed;
	motor[mRight] = new_speed;
}

void left(int rotation_speed) {
	//for(int i = 0; i < rotation_speed; i++) {
	//  motor[mLeft] = -i;
	//  motor[mRight] = i;
	//  wait1Msec(10);
 // }

	motor[mLeft] = SPEED * 0.3;
	motor[mRight] = SPEED * 2.5;
}

void right(int rotation_speed) {
	//for(int i = 0; i < rotation_speed; i++) {
	//  motor[mLeft] = i;
	//  motor[mRight] = -i;
	// // wait1Msec(10);
 // }

	motor[mLeft] = SPEED * 2.5;
	motor[mRight] = SPEED * 0.3;
}
void slow_stop(int speed) {
	int current_speed = speed;
	for(int i = speed; i > 0; i--) {
		forward(i);
		wait1Msec(10);
	}
	motor[mLeft] = 0;
	motor[mRight] = 0;
}

void play_kut_sound(int range) {
    PlayImmediateTone(range, 5);
}

void getBlootoot(string &s) {

	nSizeOfMessage = cCmdMessageGetSize(INBOX);
	if (nSizeOfMessage > kMaxSizeOfMessage)
    nSizeOfMessage = kMaxSizeOfMessage;
  if (nSizeOfMessage > 0){
  	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
  	nRcvBuffer[nSizeOfMessage] = '\0';
  	stringFromChars(s, (char *) nRcvBuffer);
  }
}


//light sensor
// > 60 - white
// < 40 - black

//color sensor
// 6 - white
// 1 - black
void startRobot() {
	int running = 1;
	int blocked = 0;
	int stopped = 0;
	while(running) {

		int light = SensorValue[leftTracker];
		int color = SensorValue[rightTracker];
	  nxtDisplayTextLine(0, "left: %d", SensorValue[leftTracker]);
	  nxtDisplayTextLine(1, "right: %d", SensorValue[rightTracker]);
	  nxtDisplayTextLine(6, "stopped: %d", stopped);

	  string command = "";
	  getBlootoot(command);

	  if(command != "") {
	  	nxtDisplayTextLine(3, command);
	  }

	  if(command == "A") {
	  	stopped = 1;
	  	slow_stop(SPEED);
	  	play_kut_sound(0);
	  }

	  if(command == "B") {
	  	stopped = 0;
	  }

		if(!stopped) {
			play_kut_sound(SensorValue[leftTracker]*29);

			if(light > 45 && color == 6) {
				forward(SPEED);
			}
			else if(color  == 1) {
				right(ROTATION_SPEED);
					wait1Msec(10);
			}
			else if(light < 45) {
				left(ROTATION_SPEED);
					wait1Msec(10);
			}
		 if(light < 45 && color == 1) {
		    slow_stop(SPEED);

			  string command = "";
			  nSizeOfMessage = 0;

			  while(!command) {
			  	getBlootoot(command);
			  	timer = nPgmTime;
			  	nxtDisplayTextLine(3, command);
			  	nxtDisplayTextLine(4, "timer: %d", timer);
		    	int passed = 0;

					if(command == "LEFT") {
						while(true) {
							int light = SensorValue[leftTracker];
							int color = SensorValue[rightTracker];

							if(light > 45) {
								left(ROTATION_SPEED);
							} else if(light < 45) {
								passed = 1;
							}

							if(passed && light > 45) {
								break;
							}
						}
					} else if (command == "RIGHT") {
						while(true) {
							int light = SensorValue[leftTracker];
							int color = SensorValue[rightTracker];

							if(color == 6) {
								right(ROTATION_SPEED);
							} else if(color == 1) {
								passed = 1;
							}

							if(passed && color == 6) {
								break;
							}
						}
					}
		  	}
			}
	 }
	 if(SensorValue(vision) < 25 ) {
	   	blocked = 1;
	   	if(blocked) {
			   slow_stop(0);
		  }
			wait1Msec(2000);
	 } else {
	    blocked = 0;
	 }
	}
}

task main()
{
	startRobot();
}
